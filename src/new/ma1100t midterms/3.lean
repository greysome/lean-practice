import tactic
import tactic.positivity
import data.set.intervals.basic
import data.rat.order
import data.nat.gcd
import data.finset.basic
import ring_theory.int.basic
open_locale big_operators
open_locale classical

def P (n m a : ℕ) : Prop := a ≤ m - 1 ∧ m < n * a

lemma exists_a {n m : ℕ} (h₁ : n > 0) (h₂ : n < m) (h₃ : ¬ n ∣ m) :
  ∃ a, P n m a :=
begin
  have : n > 1,
  { by_contra,
    push_neg at h,
    have h₄ : n = 1 := by interval_cases n,
    exact (h₄ ▸ h₃) (one_dvd _) },
  have : m > 0 := lt_trans h₁ h₂,

  use m - 1,
  refine ⟨le_refl (m-1), _⟩,
  -- Why can't `mono` prove `m + n < m + m` :madge:
  have : m + n < n * m := calc m + n < m + m : add_lt_add_left h₂ _
  ... = 2 * m : (two_mul _).symm
  ... ≤ n * m : by {mono, positivity},

  linarith
end

lemma a_prop {n m : ℕ} (h₁ : n > 0) (h₂ : n < m) (h₃ : ¬ n ∣ m) :
let a := nat.find (exists_a h₁ h₂ h₃) in
  a > 0 ∧ a * n - m < n ∧ a * n < 2 * m :=
begin
  -- Find some way to eliminate this duplication
  let Q := exists_a h₁ h₂ h₃,
  set a := nat.find Q with ha,
  obtain ⟨ha₁, ha₂⟩ := nat.find_spec Q,

  have h₄ : a > 0,
  { by_contra h', push_neg at h',
    replace h' := nat.eq_zero_of_le_zero h',
    refine nat.not_lt_zero m _,
    have := ha₂,
    rwa [←ha, h', mul_zero] at this },
  split,
    exact h₄,

  have h₅ : a * n < m + n,
  { by_contra, push_neg at h,

    have : m + n ≠ a * n,
    { by_contra h',
      have : m = (a - 1) * n := by linarith,
      rw dvd_iff_exists_eq_mul_left at h₃,
      exact h₃ (exists.intro (a - 1) this) },
    replace h := ne.lt_of_le this h,

    have h₆ : P n m (a - 1),
    { split,
      { exact le_trans (nat.pred_le _) ha₁ },
      { linarith } },

    have h₇ : a - 1 < a := by linarith,
    exact nat.find_min (exists_a h₁ h₂ h₃) h₇ h₆ },

  -- Needs to be in this exact form for `linarith` to work
  have : m ≤ a * n := by {rw mul_comm, exact le_of_lt ha₂},

  split; rw ←ha,
  { linarith },
  { calc a * n < m + n : h₅
    ... < m + m : add_lt_add_left h₂ _
    ... = 2 * m : (two_mul _).symm }
end

lemma coe_to_nat {z : ℤ} (h : z > 0) :
  z = ↑(z.to_nat) :=
by { cases z, refl, linarith [int.neg_succ_of_nat_lt_zero z] }

-- This should be in `mathlib`
lemma to_nat_of_pos {z : ℤ} (h : z > 0) : z.to_nat > 0 :=
begin
  by_contra h', push_neg at h',
  linarith [int.to_nat_eq_zero.mp $ nat.eq_zero_of_le_zero h']
end

lemma one_div_eq_mk {n : ℕ} (hn : n > 0) : 1 / ↑n = rat.mk 1 n :=
by { rw [rat.mk_eq_div, div_eq_div_iff]; simp; linarith }

lemma one_div_eq_mk' (n : ℕ+) : 1 / ↑n = rat.mk 1 n :=
by { rw [rat.mk_eq_div, div_eq_div_iff]; simp; linarith }

lemma pos_one_div {n : ℕ} (hn : n > 0) : 0 < rat.mk 1 ↑n :=
begin
  rw [rat.mk_eq_div, div_pos_iff],
  left; norm_cast,
  exact ⟨by positivity, hn⟩
end

lemma pos_one_div' (n : ℕ+) : (0 : ℚ) < 1 / ↑n :=
by simp

example (r : ℚ) (hr : r ∈ set.Ioo (0 : ℚ) 1) :
  ∃ (S : finset ℕ+), r = ∑ x in S, 1 / x :=
begin
  generalize h : r.num.to_nat - 1 = n,
  revert r,
  induction n using nat.case_strong_induction_on with i hi,

  all_goals {
    intros r hr h,
    set n := r.num with hn,
    set m : ℤ := ↑r.denom with hm,
    have npos : n > 0 := rat.num_pos_iff_pos.mpr hr.1,
    have n_lt_m : n < m := rat.lt_one_iff_num_lt_denom.mp hr.2
  },

  { have n_eq_1 : n = 1,
    { rw [←int.pred_to_nat _, int.to_nat_eq_zero] at h,
      linarith },
    use {⟨r.denom, r.pos⟩},
    rw [finset.sum_singleton],
    conv_lhs { rw [←@rat.num_denom r, ←hn, ←hm, n_eq_1] },
    simp [rat.mk_eq_div] },

  { -- Note that `n` and `m` have type `ℤ` instead of `ℕ`
    have mpos_int : m > 0 := int.coe_nat_pos.mpr r.pos,
    have npos_nat : n.to_nat > 0 := to_nat_of_pos npos,
    have n_gt_1_nat : n.to_nat > 1 := calc n.to_nat = i.succ + 1 : by linarith [h]
      ... > 0 + 1 : by simp
      ... = 1 : zero_add _,

    have n_lt_m_nat : n.to_nat < m.to_nat := by rwa int.to_nat_lt_to_nat mpos_int,
    have n_ndvd_m_nat : ¬ n.to_nat ∣ m.to_nat,
    { by_contra n_dvd_m_nat,
      have h₁ : ¬ n.to_nat.coprime m.to_nat := nat.not_coprime_of_dvd_of_dvd
        n_gt_1_nat (dvd_refl _) n_dvd_m_nat,
        
      have hnp : ¬ n.nat_abs.coprime r.denom,
      { convert h₁,
        cases r.num with _ x,
        { rw hn, refl },
        linarith [int.neg_succ_of_nat_lt_zero x] },

      exact hnp r.cop },

    let Q := exists_a npos_nat n_lt_m_nat n_ndvd_m_nat,
    set a := nat.find Q with ha,
    obtain ⟨a_lt_m, m_lt_na⟩ := nat.find_spec Q,
    obtain ⟨apos, an_sub_m_lt_n, an_lt_2m⟩ := a_prop npos_nat n_lt_m_nat n_ndvd_m_nat,
    have apos_int := int.coe_nat_pos.mpr apos,

    -- `hs'` is the clean untainted version, and
    -- we will do some manipulations on `hs`
    set s := r - rat.mk 1 a with hs',
    have hs := hs',
    rw [←@rat.num_denom r, rat.sub_def, one_mul] at hs,
    rotate, -- handle subgoals generated by `rat.sub_def`
    { exact ne_of_gt (int.coe_nat_pos.mpr r.pos) },
    { norm_cast, rw ha, linarith [a_lt_m] },

    have h₁ : n * a > 0 := int.mul_pos npos apos_int,

    have h₂ : 0 < n * a - m,
    { rw [coe_to_nat npos, sub_pos],
      norm_cast,
      assumption },

    have h₃ : s.num ≤ n * a - m,
    { refine int.le_of_dvd h₂ _,
      rw hs,
      exact (rat.num_dvd (n * ↑a - m) $ ne_of_gt $
        int.mul_pos mpos_int apos_int) },

    have h₄ : ↑a * n = ↑(a * n.to_nat),
    { rw coe_to_nat npos, norm_cast },

    have h₅ : ↑a * n - m < n,
    { rw [coe_to_nat npos, sub_lt_iff_lt_add],
      norm_cast,
      -- idk why `linarith` can't solve this...
      replace an_sub_m_lt_n := nat.add_lt_add_right an_sub_m_lt_n m.to_nat,
      rwa [mul_comm, nat.sub_add_cancel (le_of_lt m_lt_na), mul_comm] at an_sub_m_lt_n },
    
    have h₆ : s.num < n := calc s.num ≤ n * a - m : h₃
      ... = a * n - m : by rw mul_comm
      ... < n : h₅,

    have h₇ : s.num.to_nat - 1 ≤ i,
    { rw nat.sub_eq_iff_eq_add (le_of_lt n_gt_1_nat) at h,
      rw [←nat.pred_eq_sub_one, nat.pred_le_iff, ←nat.lt_succ_iff],
      calc s.num.to_nat < n.to_nat : (int.to_nat_lt_to_nat npos).mpr h₆
      ... = i.succ + 1 : h },

    have spos : 0 < s,
    { rw [hs, rat.mk_eq_div, div_pos_iff],
      left; norm_cast,
      exact ⟨h₂, nat.mul_pos r.pos apos⟩ },

    specialize hi (s.num.to_nat - 1) h₇ s _ rfl,
    { split,
      { exact spos },
      { rw hs',
        calc r - rat.mk 1 ↑a < r : (sub_lt_self_iff _).mpr (pos_one_div apos)
        ... < 1 : hr.2 } },

    obtain ⟨S, hS⟩ := hi,
    have h₈ : (⟨a, apos⟩ : ℕ+) ∉ S,
    { by_contra h',
      have h₉ : S.nonempty,
      { by_contra Sempty,
        rw finset.not_nonempty_iff_eq_empty at Sempty,
        rw [Sempty, finset.sum_empty] at hS,
        linarith [spos] },

      have h₁₀ := finset.sum_pos (λ (b : ℕ+) _, (@pos_one_div' b)) h₉,

      have h₁₁ : (1 : ℚ) / a ≤ s,
      { rw hS,
        exact finset.single_le_sum (λ (b : ℕ+) _, le_of_lt (@pos_one_div' b)) h' },

      have h₁₂ : r ≥ 2 / ↑a := calc r = s + rat.mk 1 a : by linarith [hs]
      ... ≥ 1 / ↑a + rat.mk 1 a : add_le_add_right h₁₁ _
      ... = 1 / ↑a + 1 / ↑a : by rw one_div_eq_mk apos
      ... = 2 / ↑a : by {field_simp, abel},

      have apos_rat : (↑a : ℚ) > 0 := by {norm_cast, exact apos},
      have mpos_rat : (↑m : ℚ) > 0 := by {norm_cast, zify, exact mpos_int},

      have h₁₃ : ↑a * n ≥ 2 * m,
      { rw [←@rat.num_denom r, rat.mk_eq_div] at h₁₂,
        change (2 : ℚ) / ↑a ≤ ↑n / ↑m at h₁₂,
        rw div_le_div_iff apos_rat mpos_rat at h₁₂,
        norm_cast at h₁₂,
        convert h₁₂ using 1,
        ring },

      rw h₄ at h₁₃,
      norm_cast at h₁₃,
      rw ←int.to_nat_coe_nat r.denom at h₁₃,
      linarith only [h₁₃, an_lt_2m] },

    use finset.cons ⟨a, apos⟩ S h₈,
    rw [finset.sum_cons, ←hS, one_div_eq_mk' ⟨a, apos⟩],
    simp [hs']
  }
end